------------------------
互斥同步 synchronized=可见性+有序性
非阻塞同步 AtomicInteger=volatile可见性 + CAS有序性
------------------------
绝对线程安全  定义： 调用者不需要任何额外的同步措施 
没有绝对安全的，多线程频繁的对Vector进行add get remove 操作，也会出现数组越界异常。 需要用到同步块synchronized(vector){....} 
------------------------
Object obj = new Object(); 
Object obj 反映到栈的本地变量表中， 作为一个reference类型数据出现 
new Object()  反映到堆中，形成一块内存空间 
对中还包含了能查找到此对象类型数据(对象类型，父类，接口，方法等)，存放在方法区中 
栈：可以分为JVM栈(执行字节码) 本地方法栈(执行Native方法) 
堆： 所有对象实例 和 数组  常量池， 成员变量(包括基本数据类型int) 
方法区：也称永久代，不会被回收， 存储类信息，常量，静态变量
内存 -->  主内存   --> Java堆中的对象实例 
寄存器/高速缓存  -->  工作内存 --> 对应了jvm栈中部分区域， 
----------------------------
线程的working memory工作内存是cpu的寄存器和高速缓存的抽象描述：现在的计算机，cpu在计算的时候，并不总是从内存读取数据，它的数据读取顺序优先级 是：寄存器－高速缓存－内存。线程耗费的是CPU，线程计算的时候，原始的数据来自内存，在计算过程中，有些数据可能被频繁读取，这些数据被存储在寄存器和高速缓存中，当线程计算完后，这些缓存的数据在适当的时候应该写回内存。当多个线程同时读写某个内存数据时，就会产生多线程并发问题，
用同步的方式来解决多线程问题，是由于用到了共享变量，如果没有共享变量则无需用同步。 
-----------------------------
当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。  不存在变量共享的问题 
-----------------------------------
java内存模型JMM主要是为了规定线程和内存之间的一些关系. 
系统存在一个主内存, java中所有实例变量都存储在主内存中,对于所有线程是共享的 
.每条线程都有自己的工作内存, 工作内存由缓存和堆栈两部分组成, 缓存中保存的是主存中变量的拷贝, 
缓存不总和主存同步,也就是缓存中变量的修改可能没有立刻写到 
主存中,堆栈中保存的是线程的局部变量,线程之间无法相互直接访问堆栈中的变量. 
--------------------------------------------
在上文中提到了Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。
lock方法 是基于CAS 来实现的


-----------------------------------------

共生矩阵(物物矩阵=同一用户共同出现的次数) * 用户向量
大数据可以将共生矩阵根据行来拆分成很多小矩阵 分别乘以用户向量

